WebAssembly notes:


*************************************** To make a module,
do this:
bufferSource = a ArrayBuffer or typed array with the .wasm contents
module = new WebAssembly.Module(bufferSource);

reading then creating:

fetch("simple.wasm")
.then((response) => response.arrayBuffer())
.then((bytes) => {
	const module = new WebAssembly.Module(bytes);
	//WebAssembly.instantiate(mod, importObject).then((result) =>
	//result.exports.exported_func()
	//);
});

faster alternative:
WebAssembly.compileStreaming(fetch("simple.wasm"))
.then((module, instance) => ...);



*************************************** using a module,

exports = WebAssembly.Module.exports(module)
= array of functions exported from the wasm



*************************************** To make a instance,

A WebAssembly.Instance object is a stateful, executable instance of a WebAssembly.Module. Instance objects contain all the Exported WebAssembly functions that allow calling into WebAssembly code from JavaScript.

// functions that your wasm code calls, which you must supply:
const imports = {
  imports: {
    oneFunc(argz) {
      ...
    },
    anotherFunc(args) {
      ...
    },
  },
};


const instanceInstance = new WebAssembly.Instance(module, importObject);

or


WebAssembly.instantiate(wasmBinary, importObject)
.then(  (module, instance) => )

WebAssembly.instantiate(module, importObject)
.then(instance => .....)

const instanceInstance = new WebAssembly.Instance(module, importObject);

or, shortcut,

WebAssembly.instantiateStreaming(fetch("simple.wasm"), imports)
.then(
  (module, instance) => module.instance.exports.exported_func()
);
*************************************** Memory,

memory = new WebAssembly.Memory({
	initial: initial Size in 64kiB pages,
	maximum: max Size in 64kiB pages, optional unless shared,
	shared: true for SharedArrayBuffer, false for ArrayBuffer})

*************************************** using a instance,


